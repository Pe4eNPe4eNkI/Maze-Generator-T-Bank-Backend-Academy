# Проект 2: Лабиринты

## Об алгоритмах генерации

На выбор пользователю предоставлены 2 алгоритма генерации лабиринтов
— Прима и Backtracker 

### Алгоритм Прима

1. Инициализация лабиринта

    - Лабиринт состоит из `height` на `width` клеток, где стены будут впоследствии удаляться для создания проходов.

2. Выбор начальной точки

    - Генерируется случайная начальная точка (`startX`, `startY`) для начала генерации лабиринта.
    - Эта клетка становится первым узлом, который будет использоваться для дальнейшего построения.
    - В алгоритме: `int startX = random.nextInt(width()); int startY = random.nextInt(height());`

3. Создание множеств посещённых клеток и границ (фронтир)

    - Множество посещённых клеток: используется для отслеживания клеток, которые уже добавлены в лабиринт.
    - Множество границ (фронтир): это список возможных стен, которые могут быть удалены для соединения посещённых клеток с не посещёнными. 
    - Начальная клетка добавляется в множество посещённых клеток, и для неё сразу добавляются границы. 
    - В коде: `Set<Point> visited = new HashSet<>(); List<Edge> frontier = new ArrayList<>();`

4. Добавление соседних рёбер в фронтир

    - Для каждой клетки, добавленной в лабиринт, проверяются её соседи. Если соседняя клетка ещё не посещена, то между ними добавляется граница (ребро) в список `frontier`.
    - Это выполняется в методе `addEdgesToFrontier()`, который добавляет рёбра в четырёх направлениях (вверх, вниз, влево, вправо), если соседние клетки — стены.
    - Пример:
`if (x > 1 && maze[y][x - 2] == MazeSymbol.WALL.symbol()) { frontier.add(new Edge(new Point(x, y), new Point(x - 2, y))); }
`
5. Выбор случайного ребра из фронтира

    - Пока в списке `frontier` есть рёбра, выбирается случайное ребро, соединяющее посещённую клетку с не посещённой.
    - В алгоритме:
`Edge edge = frontier.remove(random.nextInt(frontier.size()));`

6. Удаление стены и добавление новой клетки

    - Если выбранная соседняя клетка ещё не была посещена, между текущей и соседней клеткой удаляется стена. Затем новая клетка добавляется в множество посещённых клеток.
    - Стена удаляется путём замены символа стены на символ прохода `(MazeSymbol.EMPTY.symbol())`.
    - В коде:
`maze[(from.y + to.y) / 2][(from.x + to.x) / 2] = MazeSymbol.EMPTY.symbol();
maze[to.y][to.x] = MazeSymbol.EMPTY.symbol();`

7. Повторение цикла

    - Этот процесс продолжается до тех пор, пока в списке `frontier` не останется рёбер.
    - Когда список фронтира пуст, лабиринт завершён, и функция возвращает сгенерированный лабиринт.

### Алгоритм Backtracker

1. Инициализация лабиринта

    - Начальная клетка выбирается на нечетных координатах, чтобы были гарантированы пути между клетками (клетки лабиринта делятся стенами).

2. Инициализация стека и множества посещённых клеток

    - Стек используется для отслеживания текущего пути, по которому идёт генерация лабиринта.
    - Множество посещённых клеток хранит клетки, которые уже добавлены в лабиринт.
    - Начальная клетка добавляется в стек и множество посещённых клеток.

3. Основной цикл: генерация лабиринта

    - Пока стек не пустой:
      1. Текущая клетка извлекается из вершины стека.
      2. Соседняя клетка выбирается случайным образом из не посещённых соседей.
      3. Если соседняя клетка найдена:
         - Между текущей и следующей клеткой удаляется стена.
         - Соседняя клетка добавляется в стек и отмечается как посещённая.
      4. Если все соседи посещены, клетка удаляется из стека (откат назад).

4. Выбор случайного не посещённого соседа

    - Метод `getRandomUnvisitedNeighbor` выбирает случайного непосещённого соседа.
    - Сначала все возможные направления перемешиваются случайным образом.
    - Затем проверяется, находится ли соседняя клетка внутри границ лабиринта, является ли она стеной и не была ли она ранее посещена.
    - В коде:
`if (maze[newY][newX] == MazeSymbol.WALL.symbol() && !visited.contains(neighbor)) {
return neighbor; }`

5. Завершение генерации

    - Когда все клетки посещены, стек становится пустым, и функция возвращает сгенерированный лабиринт.

## Об алгоритмах поиска

Поиск пути в лабиринте осуществляется с помощью BFS и A*.
Алгоритм A* дополнительно усложнен препятствиями (ёлочками), проходя через которые
алгоритм тратит больше ресурсов, поэтому старается обходить такие клетки.

### Алгоритм BFS
BFS (поиск в ширину) — это алгоритм, который исследует узлы лабиринта уровнями,
начиная с начальной точки и постепенно расширяя радиус поиска, пока не найдёт конечную точку.

1. Инициализация:

    - Находим стартовую и конечную точки в лабиринте.
    - Создаём очередь для обхода и карту `prev` для хранения предшествующих узлов (нужна для восстановления пути).
    - Отмечаем стартовую точку как посещённую и добавляем её в очередь.
   
2. Поиск пути:

    - Пока очередь не пуста:
        1. Берём текущую точку и проверяем, достигли ли мы финиша.
        2. Исследуем все её соседние клетки.
        3. Если соседняя клетка проходима и не была посещена,
        добавляем её в очередь, помечаем как посещённую и записываем предшествующую точку.
      
3. Завершение:

    - Если нашли конечную точку, восстанавливаем путь, используя карту `prev`.
    - Если очередь пуста и путь не найден, возвращаем пустой список.

### Алгоритм A-Star (A*)

1. Инициализация:

    - Находим стартовую и конечную точки.
    - Создаём `openSet` (очередь с приоритетом) для хранения точек, которые мы собираемся исследовать, 
      отсортированных по наименьшей стоимости пути.
    - Заводим карту `gScore` для хранения минимальной стоимости достижения каждой точки от старта.
    - Карта `prev` хранит предшественников, чтобы восстанавливать путь.

2. Расчёт стоимости:

    - Для каждой исследуемой точки вычисляем:
    - G-стоимость — фактическую стоимость пути от старта до текущей точки.
    - H-стоимость — эвристическую оценку оставшегося расстояния до цели (манхеттенское расстояние).
    - F-стоимость — сумма G- и H-стоимостей, которая определяет приоритет очереди.

3. Основной цикл:

    - Пока `openSet` не пуст:
        1. Извлекаем точку с наименьшей F-стоимостью.
        2. Если достигли цели, восстанавливаем путь, используя `prev`.
        3. Исследуем соседние клетки. Для каждой клетки:
            - Если клетка непроходима или уже посещена, пропускаем её.
            - Рассчитываем новую G-стоимость. Если это препятствие, то стоимость выше.
            - Если новая G-стоимость лучше, чем старая, обновляем её, добавляем клетку в очередь и фиксируем предшественника.
4. Завершение:

    - Если очередь пуста, а цель не достигнута, возвращаем пустой список (путь не найден).

## Об отрисовки лабиринта

### 1. `printMaze(char[][] maze)`:

    - Отрисовывает лабиринт построчно в консоль.
    - Если встречает стену, использует функцию getWallCharacter() для правильного выбора символа стены.
    - Иначе, печатает символ клетки.

### 2. `markPathWithArrows(char[][] maze, List<Point> path)`:

    - Помечает найденный путь стрелками, указывающими направление между точками.
    - Для каждой точки пути устанавливает стрелку в зависимости от направления движения (вверх, вниз, влево, вправо).
    - После этого выводит обновлённый лабиринт с помощью printMaze().

### 3. `getWallCharacter(char[][] maze, int x, int y)`:

    - Возвращает символ для отображения стены в зависимости от её окружения (угол, перекрестие, горизонтальная или вертикальная линия).
    - Использует вспомогательные функции для определения формы стены.

### 4. `isWall(char[][] maze, int x, int y)`:

    - Проверяет, является ли клетка стеной и находится ли она в пределах лабиринта.

### 5. `isCorner()`, `isTShape()`, `isCross()`, `isVertical()`, `isHorizontal()`:

    - Логические функции, определяющие, как расположены стены вокруг текущей клетки.
    - На основе этих функций определяется форма стены (угловая, T-образная, перекрестная и т.д.).

### 6. `getCornerSymbol()`, `getTShapeSymbol()`:

    - Возвращают символы для углов и T-образных перекрестий в зависимости от расположения соседних стен.
